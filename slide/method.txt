这里我们称**替换人脸**为从图片库中选出来的，换到我们的目标图片上的人脸；称**目标人脸**为要被替换的人脸。在不考虑替换人脸的选择、排序和后处理等机制时，我们先讨论一下如何把一张图片库中的脸换到指定的目标人脸的方法。第一步首先要把替换人脸提取出来，这里采用的方法如下：

1. **获得轮廓**：调用Face++的API，获得人脸的轮廓。注意这里并不是要获得整张脸的轮廓，而是包含关键的面部器官的区域。因此我们选择的轮廓线是从眉毛上方出发，向下到眼角的外侧，再到下嘴唇的外侧。
2. **修改轮廓**：考虑到Face++返回的landmark都是跟面部器官紧紧贴合的，这样在之后匹配时，如果目标人脸的器官过大(-_-)，比如眼睛很大等等，就可能覆盖不上。所以这里我们会对landmark的位置进行一下修改，方法是：从鼻子的位置出发，往这些landmark连线，然后对沿着这根线的角度扩展一下距离。这样得到的新的轮廓线可以保证是包裹在原先的轮廓线之上的。
3. **提取替换人脸**：提取的过程依然是基于轮廓线的。我们这里用的是Python OpenCV提供的库：`cv2.pointPolygonTest`可以获得一个点跟轮廓线的距离，如果为负的话则表示在轮廓线之外。根据这个判断条件，我们把判定为负的像素点都改为0
4. **仿射变换**：尽管我们已经得到了替换人脸，但是目标人脸跟替换人脸之间可能有如下两种不匹配的情况：**大小不相等**和**旋转角度不相等**，而这两种不匹配都可以用仿射变换(affine transform)来解决。要想进行仿射变换，首先是要得到变换矩阵。这个变换矩阵可以用三个从原图到目标图的点对，来解一个线性方程组得到。我们选用的点对是`左眼`、`右眼`和`鼻子`的位置。求转换矩阵的过程可以用OpenCV的`warpAffine`函数，执行affine transform可以用OpenCV的`getAffineTransform`函数。(之前我自己实现过一个affine transform的版本，但是因为效果不好放弃了……)
5. **边界处理**：边界的feathering比我想象中更加重要，加上这个效果之后原先许多看起来不和谐的结构都变和谐了。具体的做法就是通过在脸部的轮廓周围d0的范围内，对人脸的边界进行融合，具体的公式是：$$I\_{result}=\alpha I\_{original face} + (1-\alpha)I_{replaced face}$$